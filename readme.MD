## ğŸ—ï¸ Infra Architecture

<p align="center">
  <img src="tf-infra-dev.drawio.svg"
       alt="Infrastructure Architecture"
       width="900">
</p>


#### VPC:
* We created a VPC with name **expense-dev-vpc** and inside VPC:
    1. We created 3 subnets:
        - *Public, Private, & Database* subnets in 2 availability zones (us-east-1a & us-east-1b)
    2. We created *Internet Gateway* and attached to VPC
    3. We created route tables:
        - *Public, Private, & Database* and their association
    4. We created a *NAT Gateway*
    5. We created routes for the route tables
    6. Established Peering connection between *expense-dev-vpc* and *default-vpc* and routes are created for peering.

#### Security Groups:

<img src="sg-rules.svg" 
     alt="Infrastructure Architecture"
     width="900">

* We created security groups
    1. *expense-dev-backend*    : Security group for backend servers
    2. *expense-dev-bastion*    : Security group for bastion servers
    3. *expense-dev-db*         : Security group for database servers
    4. *expense-dev-frontend*   : Security group for frontend servers
    5. *expense-dev-vpn*        : Security group for VPN
    6. *expense-dev-web-alb*    : SG for Web ALB Instances
    7. *expense-dev-app-alb*    : Security group for App ALB

* Created security group rules:
    1. *expense-dev-app-alb* : Port: 80, Inbound from `expense-dev-frontend & expense-dev-vpn` ; Outboud: Eveywhere (0.0.0.0/0)
    2. *expense-dev-web-alb* : Port: 80,443, Inbound from everywhere HTTP & HTTPS. Outbound: Everywhere
    3. *expense-dev-vpn*     : Port: 22,443,943,1194. Inbound & Outbound from everywhere 
    4. *expense-dev-frontend* : Port: 22,80. Inbound from `expense-dev-bastion` on port 22 & Outbound:Everywhere
    5. *expense-dev-db*      : Port: 3306, Inbound from `expense-dev-bastion, expense-dev-backend, & expense-dev-vpn`. Outbound: Everywhere
    6. *expense-dev-bastion* : Port: 22, Inbound & Outbound from Everywhere
    7. *expense-dev-backend* : Inbound: `expense-dev-vpn & expense-dev-bastion` on port 22; `expense-dev-app-alb & expense-dev-vpn` on port 8080. Outbound Everywhere.

#### Bastion:
* We created a **Bastion Server** in public subnet and installed MySQL on the server using *UserData*. This server connects to the Backend instances that are in Private Subnet. Later we moved to VPN connection instead of Bastion Server.


#### DB (Amazon RDS):
1.  Using Terraform AWS RDS Module: terraform-aws-modules/rds/aws we created DB Instance.
2. Created Route53 *db-dev.surya-devops.site* record for the RDS endpoint in existing hosted zone.

#### OpenVPN:
1. Used AWS-Marketplace AMI for OpenVPN. 
2. Launched in public subnet and associated the security group.

#### APP ALB:
* Created Application Load Balancer **expense-dev-app-alb** 
* Created a HTTP listener and associated its arn with *expense-dev-app-alb* arn
* Created a fixed response "This is the default response for the application load balancer" for this http listener.
* Created Route 53 ALIAS A record `*.app-dev.surya-devops.site` that routes traffic from the application domain to an Application Load Balancer (ALB).
    - The alias.name points to the ALB DNS name generated by AWS
    - The alias.zone_id uses the ALBâ€™s hosted zone ID (AWS-managed, region-specific)
    - Using an ALIAS record allows routing to the ALB without hard-coding IP addresses
    - Supports wildcard domains (e.g., *.app-dev) and works at the root level
    - Automatically adapts to ALB scaling and IP changes
* For expense-dev-app-alb there are 2 listener rules:

    1. If Host header (value) = backend.app-dev.surya-devops.site then:
        Forward to target group "expense-dev-backend"
        where we can check http://backend.app-dev.surya-devops.site/health , http://backend.app-dev.surya-devops.site/transaction etc. 
    
    2. Last (Default): If no other rule applies then it will return fixed response:
        "This is the default response for the application load balancer"

#### ğŸ§© Backend Infrastructure Provisioning
This module provisions and manages the backend application infrastructure using Terraform, following an AMI-based Auto Scaling pattern.

ğŸ–¥ï¸ Backend EC2 Instance (AMI Creation)
* Launches a temporary EC2 instance using the official EC2 Terraform module
* Instance is created in a private subnet with a backend security group
* A backend setup script (backend.sh) is copied and executed via SSH
* Provisioning is re-triggered only if the instance is replaced

    ğŸ“¦ Custom AMI Workflow
###### After successful provisioning:
* The EC2 instance is stopped
* A custom AMI is created from the configured instance
* The original instance is terminated
* This ensures application setup runs once and is reused consistently

    ğŸ¯ Backend Target Group
* Creates an ALB target group for the backend service
* Uses HTTP on port 8080
* Configures health checks on the /health endpoint
* Integrates with the Application Load Balancer

    ğŸš€ Launch Template
* Defines a launch template using the custom backend AMI
* Configures instance type, security groups, and tagging
* Ensures the latest template version is always used

    ğŸ“ˆ Auto Scaling Group (ASG)
* Manages backend EC2 instances using an Auto Scaling Group
* Desired capacity: 1 (scales up to 5)
* Uses rolling instance refresh on launch template changes
* Integrated with the ALB target group for health checks

    ğŸ“Š Auto Scaling Policy
* Configures target tracking scaling
* Scales based on average CPU utilization
* Maintains CPU around 10% for efficient resource usage

    ğŸŒ ALB Listener Rule
* Routes traffic from the Application Load Balancer to the backend
* Uses host-based routing
    - Example: backend.app-dev.example.com

* Requests matching the host header are forwarded to the backend target group


#### ğŸ” ACM Certificate and DNS Validation

This configuration provisions an AWS Certificate Manager (ACM) certificate and validates it using DNS validation via Route 53.

    ğŸ“œ ACM Certificate
* Creates a wildcard SSL/TLS certificate for the domain: `*.surya-devops.site`
* Uses DNS validation, which is recommended for automation and renewals
* Tags the certificate using project and environment metadata
* This certificate can be used with services such as:
    - Application Load Balancer (HTTPS)
    - CloudFront
    - API Gateway

    ğŸŒ Route 53 DNS Validation Records
* Automatically creates the required CNAME validation records in Route 53
* Uses for_each to support wildcard and future additional domain names
* Records are created in an existing public hosted zone
* Short TTL (60s) enables faster validation
* These records prove domain ownership to AWS.

    âœ… Certificate Validation
* Links the ACM certificate with the Route 53 validation records
* Completes validation once DNS records are available
* Ensures the certificate reaches the ISSUED state before use
* Terraform waits for successful validation before proceeding with dependent resources.

#### ğŸŒ Web Application Load Balancer (ALB) and DNS Configuration
This configuration provisions a public Application Load Balancer (ALB) with HTTP and HTTPS listeners and exposes it via Amazon Route 53 using an ALIAS record.

    âš–ï¸ Application Load Balancer
* Creates an internet-facing Application Load Balancer
* Deployed across public subnets for high availability
* Associated with a dedicated security group
* Used as the primary entry point for web traffic
* Deletion protection is disabled for non-production environments

    ğŸ”Š HTTP Listener (Port 80)

* Listens for incoming HTTP traffic on port 80
* Returns a fixed response by default
* Acts as a placeholder until routing rules or redirects are configured

    ğŸ” HTTPS Listener (Port 443)

* Listens for secure HTTPS traffic on port 443
* Uses an ACM-managed SSL/TLS certificate
* Enforces a standard AWS SSL security policy
* Provides a default fixed response for unmatched requests
* This ensures encrypted communication between clients and the load balancer.

    ğŸŒ Route 53 DNS Integration
* Creates a Route 53 ALIAS A record pointing to the ALB
* Uses an existing public hosted zone
* DNS name format: `web-<environment>.<domain>`
* Automatically tracks ALB IP changes without manual updates

* For expense-dev-web-alb 2 listener rules:
 
    1. If http://web-dev.surya-devops.site/ == on HTTP (port: 80) then it will return fixed response:
        "This is the default response for the WEB ALB"

    2. If https://web-dev.surya-devops.site/ == on HTTPS (port: 443) then it will return fixed response 
        - when Frontend is not configured:
          "This is the default response for the WEB ALB HTTPS"
        - when Frontend is configured:
            Expense App will be displayed


#### Frontend Infrastructure â€“ Terraform
This module provisions a scalable frontend application infrastructure on AWS using Terraform.
It follows a golden AMI + Auto Scaling Group pattern behind an Application Load Balancer (ALB).

    ğŸ“Œ Architecture Overview
* The infrastructure is built in the following stages:
* Launch a temporary EC2 instance for frontend setup
* Provision the instance using a shell script (frontend.sh)
* Stop the instance and create a custom AMI
* Terminate the temporary EC2 instance
* Use the AMI in a Launch Template
* Run the frontend using an Auto Scaling Group (ASG)
* Register instances with an ALB Target Group
* Configure host-based routing using an ALB listener rule
* Enable CPU-based auto scaling

    ğŸ§± Resources Created
##### EC2 & AMI
* Temporary EC2 instance using terraform-aws-modules/ec2-instance
* Custom frontend AMI created from the configured instance
* Instance is stopped before AMI creation to ensure consistency

##### Auto Scaling
* Launch Template using the custom AMI
* Auto Scaling Group:
    1. Min size: 1
    2. Max size: 5
    3. Desired capacity: 1
    4. Rolling instance refresh on launch template updates

##### Load Balancing
* ALB Target Group (HTTP :80)
* Health check on /
* Host-based routing: `web-<environment>.<zone_name>`

##### Scaling Policy
* Target tracking policy based on: `ASGAverageCPUUtilization = 10%`

    âš™ï¸ Provisioning Flow
EC2 (temporary)
   â†“
frontend.sh provisioning
   â†“
Instance stopped
   â†“
AMI created
   â†“
Instance terminated
   â†“
Launch Template
   â†“
Auto Scaling Group
   â†“
ALB Target Group

    ğŸ” Connectivity & Provisioning

* SSH-based provisioning using null_resource

* Script execution via: `sudo bash /tmp/frontend.sh <component> <environment>`

* Provisioning re-runs only if the EC2 instance is replaced, controlled via triggers

âš ï¸ Note: SSH password authentication is used here for simplicity.
For production, prefer SSH key pairs or AWS SSM Session Manager.

ğŸ“¥ Prerequisites

* Terraform >= 1.x
* AWS CLI configured with appropriate permissions
* Existing resources stored in SSM Parameter Store:
* VPC ID
* Public subnet IDs
* Frontend security group ID
* ALB listener ARN
* Internet access from public subnet
* `frontend.sh` script present in the same directory

âš ï¸ Important Notes

* null_resource with provisioners is not recommended for long-term ASG workloads
* This approach is acceptable for AMI baking, but consider:
    1. cloud-init
    2. Packer
    3. CI/CD-based AMI pipelines
* The AMI name must be unique per region
* Manual changes to instances may be overwritten by ASG refresh

####   ğŸŒ Nginx Reverse Proxy Configuration (Frontend)
The frontend application uses Nginx as a reverse proxy to route API traffic to the backend service and expose a lightweight health endpoint for load balancer checks.

ğŸ”§ Nginx Configuration Snippet
proxy_http_version 1.1;

location /api/ {
  proxy_pass http://{{BACKEND_HOST_URL}}/;
}

location /health {
  stub_status on;
  access_log off;
}

* Routes all /api/* requests from the frontend to the backend service
Examaple:

When we add an expense on the frontend app `Expense APP` the request
https://web-dev.surya-devops.site/api/transaction will route to {{BACKEND_HOST_URL}} == backend.app-dev.surya-devops.site

* Backend ALB DNS name or
* Backend internal load balancer / service endpoint
* Keeps frontend and backend loosely coupled

/health Endpoint
location /health {
  stub_status on;
  access_log off;
}

* Lightweight endpoint used for:
    1. ALB health checks
    2. Instance liveness validation
* stub_status provides Nginx internal metrics
* Access logging disabled to reduce noise

    ğŸ©º Load Balancer Health Checks
The ALB target group health check is aligned with this configuration:
* Path: /health
* Protocol: HTTP
* Port: 80
* Expected response: 200

This ensures:
* Only healthy frontend instances receive traffic
* Fast detection of failed instances during ASG refresh

âš ï¸ Important Notes
* Ensure ngx_http_stub_status_module is enabled in the Nginx build
* BACKEND_HOST_URL must be reachable from frontend instances
* For HTTPS backends, update proxy_pass accordingly:
    proxy_pass https://backend.example.com;


### CloudFront CDN â€“ Web Frontend (Terraform)
This Terraform configuration provisions an AWS CloudFront distribution in front of a web application and maps it to a custom domain using Route 53.
It is designed to improve performance, security, and scalability for frontend traffic.

    ğŸ“Œ Architecture Overview
User -> CloudFront (CDN) -> Frontend ALB -> https://web-dev.surya-devops.site/ -> Frontend Target group on port 80 -> if /api/ -> Backend Load Balancer (backend.app-dev.surya-devops.site) -> Backend Target Group on port 80 -> Database

```mermaid
flowchart LR
    User --> CloudFront[CloudFront CDN]
    CloudFront -->|HTTPS| FrontendALB[Frontend ALB :443]
    FrontendALB --> FrontendTG[Frontend Target Group :80]
    FrontendTG --> Nginx[Nginx Frontend]
    Nginx -->|/api| BackendALB[Backend ALB :443]
    BackendALB --> BackendTG[Backend Target Group :80]
    BackendTG --> BackendApp[Backend Service]
    BackendApp --> Database[Database]


* CloudFront acts as the global CDN
* Origin is a web endpoint (typically ALB-backed)
* Route 53 provides DNS mapping
* HTTPS is enforced end-to-end

ğŸ§± Resources Created

    ğŸŒ CloudFront Distribution

* Custom origin pointing to: web-<environment>.<zone_name> `# web-dev.surya-devops.site`
* HTTPS-only communication between CloudFront and origin
* TLS 1.2 enforced
* Compression enabled

    ğŸŒ Route 53 DNS Record

* Alias A record: web-cdn.<zone_name> `web-cdn.surya-devops.site`
* Points directly to the CloudFront distribution
* No public IPs required (AWS-managed alias)

    ğŸ” Origin Configuration
* origin_protocol_policy = "https-only"
* origin_ssl_protocols   = ["TLSv1.2"]

* CloudFront communicates with the origin only over HTTPS
* Prevents insecure backend access
* http_port = 80 is mandatory but unused

    âš¡ Cache Behaviors
ğŸ”¹ Default Cache Behavior (Dynamic Content)

* Path: /*
* Allowed methods: `GET, HEAD, OPTIONS, POST, PUT, PATCH, DELETE`
* Cached methods: `GET, HEAD`
* Caching: Disabled (dynamic content)
* Viewer policy: Redirect HTTP â†’ HTTPS
* Compression: Enabled

Used for:

* API responses
* Dynamic web content
* Authenticated traffic

ğŸ”¹ Ordered Cache Behavior â€“ Images

* Path: /images/*
* Methods: GET, HEAD, OPTIONS
* Caching: Enabled
* TTL:
    - Default: 1 day
    - Max: 1 year
* Compression: Enabled

Used for:

* Static images
* Media assets

ğŸ”¹ Ordered Cache Behavior â€“ Static Assets

* Path: /static/*
* Methods: GET, HEAD, OPTIONS
* Caching: Enabled
* TTL:
    - Default: 1 day
    - Max: 1 year
* Compression: Enabled

Used for:

* JS, CSS
* Frontend static bundles

ğŸ” Security Controls
ğŸ”’ HTTPS Enforcement

* Viewer protocol policy: `redirect-to-https`

* Minimum TLS version: `TLSv1.2_2021`

ğŸŒ Geo Restriction (Whitelist)
locations = ["US", "IN", "GB", "DE"]

* Content is served only to these countries
* Requests from other regions are blocked

ğŸ”‘ SSL / Certificate Management

* Uses ACM certificate from SSM Parameter Store
* Certificate must: Be in us-east-1 (CloudFront requirement)

* Cover the alias domain: web-<component>.<zone_name> == `web-cdn.surya-devops.site`

* ssl_support_method = "sni-only"


ğŸŒ DNS Configuration (Route 53)

* Existing hosted zone `surya-devops.site` is reused

* Alias record: web-cdn.<zone_name> == `web-cdn.surya-devops.site`

* Points to:
    - CloudFront domain name
    - CloudFront hosted zone ID

Benefits:
* No DNS TTL delays
* AWS-native health awareness

ğŸ·ï¸ Tagging Strategy

Common tags applied to CloudFront distribution

Resource name includes: <project>-<environment>